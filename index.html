<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clash Royale - Ultimate Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(90deg,#000000, #070545, #000000);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            touch-action: manipulation;
        }

        #gameContainer {
            width: 420px;
            height: 750px;
            background: #2a2a3e;
            border-radius: 20px;
            box-shadow: 0 20px 100px rgba(255,255,255,0.3);
            position: relative;
            overflow: hidden;
        }

        /* Start Menu Styles */
        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #0f0f1e);
            display: flex;
            flex-direction: column;
            z-index: 1000;
        }

        .menu-header {
            padding: 20px;
            text-align: center;
            background: linear-gradient(135deg, #1a1a2e, #2d3561, #1a1a2e);
            border-bottom: 2px solid #4a4a6a;
            position: relative;
        }

        .menu-header h1 {
            color: #fff;
            font-size: 36px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .user-info {
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .trophy-counter {
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            margin-top: 5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .auth-buttons {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .auth-button-small {
            padding: 5px 10px;
            font-size: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid #4a4a6a;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .auth-button-small:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }

        .menu-tabs {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }

        .menu-tab {
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .menu-tab.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-color: #667eea;
        }

        .menu-tab:hover {
            transform: translateY(-2px);
        }

        .menu-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        #authSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 20px;
        }

        .auth-button {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
            width: 80%;
        }

        .auth-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.5);
        }

        .play-button {
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .play-button:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 25px rgba(76, 175, 80, 0.5);
        }

        #playSection {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        #cardsSection {
            display: none;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .selectable-card {
            width: 70px;
            height: 100px;
            background: linear-gradient(135deg, #2d3561, #1a1a2e);
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .selectable-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .selectable-card.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }

        .selectable-card-icon {
            font-size: 30px;
            margin-bottom: 5px;
        }

        .selectable-card-name {
            font-size: 10px;
            color: white;
            text-align: center;
        }

        .selectable-card-cost {
            position: absolute;
            bottom: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            background: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .selected-cards-display {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .selected-cards-display h3 {
            color: white;
            margin-bottom: 10px;
            text-align: center;
        }

        .selected-cards-list {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .selected-card-slot {
            width: 60px;
            height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed #4a4a6a;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        #startGameBtn {
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #4CAF50, #8BC34A);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            width: 100%;
        }

        #startGameBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #startGameBtn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        /* Account Creation and Sign In Styles */
        #createAccountSection, #signInSection {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }

        .auth-form {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 30px;
            width: 80%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .auth-form h2 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-group label {
            color: white;
            font-size: 14px;
        }

        .input-group input {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
        }

        .input-group input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .auth-submit-button {
            padding: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            font-size: 16px;
        }

        .auth-submit-button:hover {
            transform: scale(1.05);
        }

        .back-button {
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            align-self: center;
        }

        .back-button:hover {
            transform: translateY(-2px);
        }

        .error-message {
            color: #f44336;
            text-align: center;
            font-size: 14px;
            margin-top: 10px;
        }

        .success-message {
            color: #4CAF50;
            text-align: center;
            font-size: 14px;
            margin-top: 10px;
        }

        /* Game Styles */
        #elixirBar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #4a4a6a;
            z-index: 100;
        }

        #elixirFill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        #timer {
            position: absolute;
            bottom: 210px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 16px;
            z-index: 100;
        }

        #arena {
            width: 100%;
            height: 550px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D982 40%, #90EE90 60%, #98D982 100%);
            position: relative;
            border-top: 3px solid #4a4a4a;
            border-bottom: 3px solid #4a4a4a;
        }

        .river {
            position: absolute;
            width: 100%;
            height: 60px;
            background: linear-gradient(90deg, #4A90E2, #357ABD, #4A90E2);
            top: 50%;
            transform: translateY(-50%);
            border-top: 2px solid #2E5F8A;
            border-bottom: 2px solid #2E5F8A;
            overflow: hidden;
            z-index: 5;
        }

        .river::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                rgba(255,255,255,0.1) 0px,
                rgba(255,255,255,0.1) 20px,
                transparent 20px,
                transparent 40px
            );
            animation: riverFlow 5s linear infinite;
        }

        @keyframes riverFlow {
            0% { left: -100%; }
            100% { left: 0%; }
        }

        .bridge {
            position: absolute;
            width: 80px;
            height: 70px;
            background: linear-gradient(to bottom, #8B7355, #6B5B45);
            top: 50%;
            transform: translateY(-50%);
            border: 2px solid #5B4B35;
            border-radius: 5px;
            z-index: 6;
        }

        .bridge.left {
            left: 80px;
        }

        .bridge.right {
            right: 80px;
        }

        .bridge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.1) 0px,
                rgba(0,0,0,0.1) 5px,
                transparent 5px,
                transparent 10px
            );
        }

        .grid-cell {
            position: absolute;
            border: 1px dashed rgba(255,255,255,0.1);
            transition: all 0.2s;
            touch-action: none;
        }

        .grid-cell.valid-drop {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .grid-cell.invalid-drop {
            background: rgba(244, 67, 54, 0.3);
            border-color: #f44336;
        }

        .tower {
            position: absolute;
            width: 60px;
            height: 80px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 10;
        }

        .tower.player {
            background: linear-gradient(135deg, #667eea, #764ba2);
            bottom: 10px;
        }

        .tower.enemy {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            top: 10px;
        }

        .tower.king {
            width: 80px;
            height: 100px;
            left: 50%;
            transform: translateX(-50%);
        }

        .tower.princess-left {
            left: 80px;
        }

        .tower.princess-right {
            right: 80px;
        }

        .tower.destroyed {
            display: none;
        }

        .tower-health {
            width: 100%;
            height: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }

        .tower-health-bar {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
            border-radius: 4px;
        }

        .tower-hp-text {
            position: absolute;
            top: -20px;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }

        .unit {
            position: absolute;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.1s linear;
            cursor: pointer;
            z-index: 20;
        }

        /* Visual for Prince charging state */
        .unit.charging {
            box-shadow: 0 0 18px rgba(255,215,0,0.9);
            transform: scale(1.08);
        }

        /* Flying units appear slightly elevated */
        .unit.flying { transform: translateY(-6px); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }

        /* (Removed visual for slowed/frozen units) */

        /* Unit icon wrapper and charge ring */
        .unit .unit-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            position: relative;
        }

        .unit .charge-ring {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%) scale(0.6);
            border-radius: 50%;
            border: 2px solid rgba(255,215,0,0.0);
            box-shadow: 0 0 0 rgba(255,215,0,0);
            transition: all 0.2s ease-out;
            pointer-events: none;
            z-index: 5;
        }

        .unit.charging .charge-ring {
            border-color: rgba(255,215,0,0.9);
            box-shadow: 0 0 10px rgba(255,215,0,0.9);
            transform: translate(-50%, -50%) scale(1);
            animation: chargePulse 1s ease-out infinite;
        }

        @keyframes chargePulse {
            0% { transform: translate(-50%, -50%) scale(0.9); opacity: 1 }
            50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.8 }
            100% { transform: translate(-50%, -50%) scale(0.9); opacity: 1 }
        }

        /* (Removed blue-hit flash styles) */

        /* Visual for Prince charging state */
        .unit.charging {
            box-shadow: 0 0 18px rgba(255,215,0,0.9);
            transform: scale(1.08);
        }

        .unit.player {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.5);
        }

        .unit.enemy {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            box-shadow: 0 2px 10px rgba(245, 87, 108, 0.5);
        }

        .unit.tower {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            background: linear-gradient(135deg, #8B4513, #D2691E);
            box-shadow: 0 2px 10px rgba(139, 69, 19, 0.5);
            z-index: 15;
        }

        .unit.tower.player {
            background: linear-gradient(135deg, #8B4513, #D2691E);
            box-shadow: 0 2px 10px rgba(139, 69, 19, 0.5);
        }

        .unit.tower.enemy {
            background: linear-gradient(135deg, #8B0000, #A52A2A);
            box-shadow: 0 2px 10px rgba(139, 0, 0, 0.5);
        }

        .unit.health-bar {
            position: absolute;
            width: 35px;
            height: 4px;
            background: rgba(0,0,0,0.3);
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
        }

        .unit.tower .health-bar {
            width: 50px;
        }

        .unit.health-fill {
            height: 100%;
            background: #4CAF50;
            border-radius: 2px;
            transition: width 0.2s;
        }

        .unit-hp-text {
            position: absolute;
            top: -15px;
            color: white;
            font-size: 8px;
            font-weight: bold;
        }

        .unit.being-pulled {
            transition: all 0.5s ease-out;
        }

        .unit.jumping {
            animation: jump 0.5s ease-out forwards;
            z-index: 30;
        }

        @keyframes jump {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        #cardDeck {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 200px;
            background: linear-gradient(to bottom, #1a1a2e, #0f0f1e);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px;
        }

        .card {
            width: 70px;
            height: 100px;
            background: linear-gradient(135deg, #2d3561, #1a1a2e);
            border: 2px solid #4a4a6a;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.3s;
            position: relative;
            touch-action: none;
        }

        .card:hover:not(.disabled) {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .card.drag-preview {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            opacity: 0.9;
            transform-origin: top left;
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-icon {
            font-size: 30px;
            margin-bottom: 5px;
        }

        .card-cost {
            position: absolute;
            bottom: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            background: #4CAF50;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .card.disabled .card-cost {
            background: #666;
        }

        .card-cycle-indicator {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 20px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
        }

        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #gameOver h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }

        #gameOver p {
            color: white;
            font-size: 20px;
            margin-bottom: 20px;
        }

        #restartBtn {
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.3s;
        }

        #restartBtn:hover {
            transform: scale(1.1);
        }

        .damage-text {
            position: absolute;
            color: #ff4444;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
            z-index: 50;
        }

        @keyframes damageFloat {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }

        .explosion {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff6b6b, #ff4444, transparent);
            animation: explode 0.3s ease-out forwards;
            pointer-events: none;
            z-index: 30;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .spell-effect {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 25;
        }

        .fireball-effect {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #ff9800, #ff5722, transparent);
            animation: spellPulse 0.5s ease-out forwards;
        }

        .arrow-effect {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, red, orange, transparent);
            animation: spellPulse 0.5s ease-out forwards;
        }
        
        .lightning-effect {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #ffeb3b, #ffc107, transparent);
            animation: spellPulse 0.5s ease-out forwards;
        }

        .freeze-effect {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #03a9f4, #0288d1, transparent);
            animation: spellPulse 1s ease-out forwards;
        }

        .tornado-effect {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(150, 150, 150, 0.8), rgba(200, 200, 200, 0.4), transparent);
            animation: tornadoSpin 1.5s ease-out forwards;
        }

        /* Projectile visuals */
        .projectile {
            position: absolute;
            pointer-events: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            transition: transform 0.05s linear;
        }
        .projectile.arrow { background: linear-gradient(90deg,#a86206 0%, #664c05 100%); width:10px;height:4px;border-radius:3px; }
        .projectile.fire { background: radial-gradient(circle, #ff9 0%, #f60 60%, transparent 100%); width:14px;height:14px }
        .projectile.orb { background: radial-gradient(circle, rgb(240, 176, 40), rgb(255, 153, 85)); }

        @keyframes tornadoSpin {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.2) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(1) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes spellPulse {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        /* (Removed global .frozen styles and freeze keyframes) */

        .projectile {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            z-index: 15;
        }

        .arrow {
            background: linear-gradient(135deg, #8B4513, #A0522D);
            box-shadow: 0 0 5px rgba(139, 69, 19, 0.5);
        }

        .fireball {
            background: radial-gradient(circle, #ff9800, #ff5722);
            box-shadow: 0 0 10px rgba(255, 87, 34, 0.7);
        }

        .iceball {
            background: radial-gradient(circle, #03a9f4, #0288d1);
            box-shadow: 0 0 10px rgba(3, 169, 244, 0.7);
        }

        @keyframes screenShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        p {
            color: white;
            margin: 0;
        }

        @media (max-width: 420px) {
            body {
                align-items: flex-start;
                padding: 20px 0;
            }

            #gameContainer {
                transform-origin: top center;
                transform: scale(calc(100vw / 420));
            }
        }
    </style>
</head>
<body>
    
    <div id="gameContainer">
        <div id="startMenu">
            <div class="menu-header">
                <h1>Clash Royale - NG</h1>
                <div class="user-info" id="userInfo" style="display: none">
                    Welcome, <span id="usernameDisplay"></span>
                </div>
                <div class="trophy-counter" id="trophyCounter" style="display: none;">
                    üèÜ Trophies: <span id="trophyCount">0</span>
                </div>
                <div class="menu-tabs" id="menuTabs" style="display: none;">
                    <div class="menu-tab active" data-tab="play">Play</div>
                    <div class="menu-tab" data-tab="cards">Cards</div>
                </div>
                <div class="auth-buttons" id="authButtons" style="display: none;">
                    <button class="auth-button-small" id="signInMenuBtn">Sign In</button>
                    <button class="auth-button-small" id="createAccountMenuBtn">Create Account</button>
                </div>
            </div>
            <div class="menu-content">
                <!-- Authentication Section -->
                <div id="authSection">
                    <button class="auth-button" id="signInBtn">Sign In</button>
                    <button class="auth-button" id="createAccountBtn">Create Account</button>
                </div>
                
                <!-- Play Section -->
                <div id="playSection">
                    <button class="play-button">Quick Match</button>
                </div>
                
                <!-- Cards Section -->
                <div id="cardsSection">
                    <div class="selected-cards-display">
                        <h3>Your Deck (8 cards)</h3>
                        <div class="selected-cards-list">
                            <div class="selected-card-slot" data-slot="0"></div>
                            <div class="selected-card-slot" data-slot="1"></div>
                            <div class="selected-card-slot" data-slot="2"></div>
                            <div class="selected-card-slot" data-slot="3"></div>
                            <div class="selected-card-slot" data-slot="4"></div>
                            <div class="selected-card-slot" data-slot="5"></div>
                            <div class="selected-card-slot" data-slot="6"></div>
                            <div class="selected-card-slot" data-slot="7"></div>
                        </div>
                    </div>
                    <div class="cards-grid" id="cardsGrid"></div>
                    <button id="startGameBtn" disabled>Select 8 Cards</button>
                </div>
                
                <!-- Create Account Section -->
                <div id="createAccountSection">
                    <div class="auth-form">
                        <h2>Create Account</h2>
                        <div class="input-group">
                            <label for="newUsername">Username</label>
                            <input type="text" id="newUsername" placeholder="Enter a username" maxlength="20">
                        </div>
                        <button class="auth-submit-button" id="createAccountSubmitBtn">Create Account</button>
                        <div id="createAccountMessage"></div>
                        <button class="back-button" id="backFromCreateBtn">Back</button>
                    </div>
                </div>
                
                <!-- Sign In Section -->
                <div id="signInSection">
                    <div class="auth-form">
                        <h2>Sign In</h2>
                        <div class="input-group">
                            <label for="username">Username</label>
                            <input type="text" id="username" placeholder="Enter your username" maxlength="20">
                        </div>
                        <button class="auth-submit-button" id="signInSubmitBtn">Sign In</button>
                        <div id="signInMessage"></div>
                        <button class="back-button" id="backFromSignInBtn">Back</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="elixirBar" style="display: none;">
            <div id="elixirFill">10/10</div>
        </div>
        
        <div id="timer" style="display: none;">2:30</div>
        
        <div id="arena" style="display: none;">
            <div class="river">
                <div class="bridge left"></div>
                <div class="bridge right"></div>
            </div>
            
            <div class="tower enemy king" data-type="enemy" data-tower="king">
                <span class="tower-hp-text">10000</span>
                <span>üëë</span>
                <div class="tower-health">
                    <div class="tower-health-bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="tower enemy princess-left" data-type="enemy" data-tower="left">
                <span class="tower-hp-text">5000</span>
                <span>üè∞</span>
                <div class="tower-health">
                    <div class="tower-health-bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="tower enemy princess-right" data-type="enemy" data-tower="right">
                <span class="tower-hp-text">5000</span>
                <span>üè∞</span>
                <div class="tower-health">
                    <div class="tower-health-bar" style="width: 100%"></div>
                </div>
            </div>
            
            <div class="tower player king" data-type="player" data-tower="king">
                <span class="tower-hp-text">10000</span>
                <span>üëë</span>
                <div class="tower-health">
                    <div class="tower-health-bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="tower player princess-left" data-type="player" data-tower="left">
                <span class="tower-hp-text">5000</span>
                <span>üè∞</span>
                <div class="tower-health">
                    <div class="tower-health-bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="tower player princess-right" data-type="player" data-tower="right">
                <span class="tower-hp-text">5000</span>
                <span>üè∞</span>
                <div class="tower-health">
                    <div class="tower-health-bar" style="width: 100%"></div>
                </div>
            </div>
        </div>
        
        <div id="cardDeck" style="display: none;"></div>
        
        <div id="gameOver">
            <h2 id="gameOverText">Victory!</h2>
            <p id="trophyChange">+30 Trophies</p>
            <button id="restartBtn">Play Again</button>
        </div>
    </div>

    <script>
        class Game {
            constructor() {
                this.elixir = 10;
                this.maxElixir = 10;
                this.units = [];
                this.gridSize = { rows: 8, cols: 6 };
                this.cellSize = { width: 70, height: 68 };
                this.selectedCards = [];
                this.playerDeck = [];
                this.enemyDeck = [];
                this.gameStarted = false;
                this.gameOver = false;
                this.timeLeft = 120; // 2 minutes in seconds
                this.trophies = 0;
                this.currentUser = null;
                // Global engagement distance for troops (pixels)
                this.troopTargetRange = 200;
                
                // River and bridge positions
                this.riverTop = 275 - 30;
                this.riverBottom = 275 + 30;
                this.bridges = [
                    { left: 80, right: 160, centerX: 120 }, // Left bridge
                    { left: 260, right: 340, centerX: 300 } // Right bridge
                ];
                
                // Tower HP values
                this.towers = {
                    player: {
                        king: { health: 10000, maxHealth: 10000, destroyed: false },
                        left: { health: 5000, maxHealth: 5000, destroyed: false },
                        right: { health: 5000, maxHealth: 5000, destroyed: false }
                    },
                    enemy: {
                        king: { health: 10000, maxHealth: 10000, destroyed: false },
                        left: { health: 5000, maxHealth: 5000, destroyed: false },
                        right: { health: 5000, maxHealth: 5000, destroyed: false }
                    }
                };
                
                // All available cards
                this.allCards = {
                    knight: { name: 'Knight', cost: 3, health: 1000, damage: 150, speed: 1, range: 50, icon: 'üõ°', type: 'troop', src: 'assets/images/KnightCard.png' },
                    archer: { name: 'Archer', cost: 2, health: 400, damage: 100, speed: 1.5, range: 130, icon: 'üèπ', type: 'troop', src: "assets/images/ArchersCard.png", canHitAir: true, projectile: true, projectileSpeed: 0.6, projectileClass: 'arrow' },
                    giant: { name: 'Giant', cost: 5, health: 2000, damage: 250, speed: 0.8, range: 30, icon: 'üëπ', type: 'troop', targetsTowersOnly: true, src: 'assets/images/GiantCard.png' },
                    dragon: { name: 'Dragon', cost: 6, health: 1000, damage: 250, speed: 1.8, range: 120, icon: 'üêâ', type: 'troop', flying: true, src: 'assets/images/bb dragon.png', projectile: true, projectileSpeed: 0.9, projectileClass: 'fire' },
                    demon: { name: 'Mini Pekka', cost: 4, health: 600, damage: 500, speed: 1.5, range: 30, icon: 'ü§ñ', type: 'troop' , src: "assets/images/MiniPEKKACard.png" },
                    // Prince: charges while moving. When fully charged, next attack deals boosted damage.
                    prince: {
                        name: 'Prince', cost: 5, health: 1200, damage: 250, speed: 1.3, range: 30, icon: 'üê¥', type: 'troop', canJumpRiver: true, src: 'assets/images/PrinceCard.png',
                        // charge mechanics
                        chargeSpeedMultiplier: 2.5,
                        chargeThreshold: 60, // number of movement ticks required to start charge
                        chargeBonusMultiplier: 2
                    },
                    wizard: { name: 'Skeleton', cost: 1, health: 100, damage: 100, speed: 4, range: 50, icon: '‚ò†', type: 'troop', src: "assets/images/SkeletonsCard.png" },
                    
                    barbarian: { name: 'Barbarian', cost: 3, health: 700, damage: 200, speed: 2, range: 40, icon: 'üó°Ô∏è', type: 'troop', src: "assets/images/BarbariansCard.png" },
                    minion: { name: 'Minion', cost: 3, health: 300, damage: 100, speed: 2.5, range: 80, icon: 'üëæ', type: 'troop' , flying:true , src: "assets/images/MinionsCard.png" },
                    megaknight: { name: 'Mega Knight', cost: 7, health: 1000, damage: 250, speed: 1, range: 50, icon: 'üëª', type: 'troop', jumpDamage: 400, src:"assets/images/MegaKnightCard.png" },
                    hogrider: { name: 'Hog Rider', cost: 5, health: 900, damage: 300, speed: 2, range: 60, icon: 'üêó', type: 'troop', canJumpRiver: true, targetsTowersOnly: true, src: "assets/images/HogRiderCard.png" },
                    fireball: { name: 'Fireball', cost: 4, damage: 600, radius: 100, icon: 'üî•', type: 'spell' , src: "assets/images/FireballCard.png" },
                    lightning: { name: 'Lightning', cost: 6, damage: 1000, radius: 100, icon: '‚ö°', type: 'spell' , src: "assets/images/LightningCard.png" },
                    freeze: { name: 'Freeze', cost: 3, duration: 2000, radius: 120, icon: '‚ùÑÔ∏è', type: 'spell' , src: "assets/images/FreezeCard.png" },
                    arrows: { name: 'Arrows', cost: 2, damage: 200, radius: 175, icon: '‚Ü¢', type: 'spell' ,src: "assets/images/ArrowsCard.png"},
                    tornado: { name: 'Tornado', cost: 2, radius: 150, icon: 'üå™', type: 'spell' , src: "assets/images/TornadoCard.png"},
                    decoy: { name: 'cannon', cost: 3, health: 1000, damage: 150, speed: 0, range: 100, icon: 'Ô∏èüè∞', type: 'tower' , canHitAir: true, attackInterval: 1000, projectile: true, projectileSpeed: 0.7, projectileClass: 'fire', src: "assets/images/CannonCard.png"},
                    pecka: { name: 'pecka', cost: 9, health: 2000, damage: 1200, speed: 0.75, range: 50, icon: 'ü¶ã', type: 'troop' , src: "assets/images/PEKKACard.png"},
                    snipe: { name: 'princess', cost: 3, health: 200, damage: 150, speed: 0.5, range: 200, icon: 'üî´', type: 'troop', canHitAir: true, src: "assets/images/PrincessCard.png", projectile: true, projectileSpeed: 0.8, projectileClass: 'arrow' },
                    wiz: { name: 'wizard', cost: 5, health: 600, damage: 200, speed: 1, range: 100, icon: 'üßô', type: 'troop', splashDamage: true, splashRadius: 85, canHitAir: true, src:"assets/images/WizardCard.png", projectile: true, projectileSpeed: 0.9, projectileClass: 'orb' }
                };
                
                this.draggedCard = null;
                this.dragSourceCard = null;
                this.touchDragState = null;
                this.boundTouchMove = null;
                this.boundTouchEnd = null;
                this.init();
            }

            init() {
                this.setupAuth();
                this.setupMenu();
                this.setupEventListeners();
            }

            setupAuth() {
                // Check if user is already signed in
                const savedUser = localStorage.getItem('currentUser');
                if (savedUser) {
                    this.currentUser = savedUser;
                    this.loadUserData();
                    this.showMainMenu();
                } else {
                    this.showAuthSection();
                }
            }

            showAuthSection() {
                document.getElementById('authSection').style.display = 'flex';
                document.getElementById('playSection').style.display = 'none';
                document.getElementById('cardsSection').style.display = 'none';
                document.getElementById('createAccountSection').style.display = 'none';
                document.getElementById('signInSection').style.display = 'none';
                document.getElementById('userInfo').style.display = 'none';
                document.getElementById('trophyCounter').style.display = 'none';
                document.getElementById('menuTabs').style.display = 'none';
                document.getElementById('authButtons').style.display = 'none';
            }

            showMainMenu() {
                document.getElementById('authSection').style.display = 'none';
                document.getElementById('playSection').style.display = 'flex';
                document.getElementById('cardsSection').style.display = 'none';
                document.getElementById('createAccountSection').style.display = 'none';
                document.getElementById('signInSection').style.display = 'none';
                document.getElementById('userInfo').style.display = 'block';
                document.getElementById('trophyCounter').style.display = 'block';
                document.getElementById('menuTabs').style.display = 'flex';
                document.getElementById('authButtons').style.display = 'flex';
                
                // Update user info display
                document.getElementById('usernameDisplay').textContent = this.currentUser;
                this.updateTrophyDisplay();
            }

            setupMenu() {
                // Populate cards grid
                const cardsGrid = document.getElementById('cardsGrid');
                cardsGrid.innerHTML = '';
                
                Object.entries(this.allCards).forEach(([key, card]) => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'selectable-card';
                    cardElement.dataset.card = key;
                    if (card.src) {
                        cardElement.innerHTML = `
                        <div class="selectable-card-icon"><img src="${card.src}" width="30px"/></div>
                        <div class="selectable-card-name">${card.name}</div>
                        <div class="selectable-card-cost">${card.cost}</div>
                    `;
                    } else {
                        cardElement.innerHTML = `
                            <div class="selectable-card-icon">${card.icon}</div>
                            <div class="selectable-card-name">${card.name}</div>
                            <div class="selectable-card-cost">${card.cost}</div>
                        `;
                    }
                    cardsGrid.appendChild(cardElement);
                });
            }

            setupEventListeners() {
                // Authentication buttons in menu
                document.getElementById('signInMenuBtn').addEventListener('click', () => {
                    document.getElementById('authSection').style.display = 'none';
                    document.getElementById('playSection').style.display = 'none';
                    document.getElementById('cardsSection').style.display = 'none';
                    document.getElementById('createAccountSection').style.display = 'none';
                    document.getElementById('signInSection').style.display = 'flex';
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('trophyCounter').style.display = 'none';
                    document.getElementById('menuTabs').style.display = 'none';
                    document.getElementById('authButtons').style.display = 'none';
                });

                document.getElementById('createAccountMenuBtn').addEventListener('click', () => {
                    document.getElementById('authSection').style.display = 'none';
                    document.getElementById('playSection').style.display = 'none';
                    document.getElementById('cardsSection').style.display = 'none';
                    document.getElementById('createAccountSection').style.display = 'flex';
                    document.getElementById('signInSection').style.display = 'none';
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('trophyCounter').style.display = 'none';
                    document.getElementById('menuTabs').style.display = 'none';
                    document.getElementById('authButtons').style.display = 'none';
                });

                // Authentication buttons
                document.getElementById('signInBtn').addEventListener('click', () => {
                    document.getElementById('authSection').style.display = 'none';
                    document.getElementById('signInSection').style.display = 'flex';
                });

                document.getElementById('createAccountBtn').addEventListener('click', () => {
                    document.getElementById('authSection').style.display = 'none';
                    document.getElementById('createAccountSection').style.display = 'flex';
                });

                document.getElementById('backFromSignInBtn').addEventListener('click', () => {
                    if (this.currentUser) {
                        this.showMainMenu();
                    } else {
                        this.showAuthSection();
                    }
                });

                document.getElementById('backFromCreateBtn').addEventListener('click', () => {
                    if (this.currentUser) {
                        this.showMainMenu();
                    } else {
                        this.showAuthSection();
                    }
                });

                // Create account form
                document.getElementById('createAccountSubmitBtn').addEventListener('click', () => {
                    const username = document.getElementById('newUsername').value.trim();
                    const messageEl = document.getElementById('createAccountMessage');
                    
                    if (!username) {
                        messageEl.innerHTML = '<div class="error-message">Please enter a username</div>';
                        return;
                    }
                    
                    // Get existing users from localStorage
                    let users = JSON.parse(localStorage.getItem('users') || '{}');
                    
                    if (users[username]) {
                        messageEl.innerHTML = '<div class="error-message">Username already exists</div>';
                        return;
                    }
                    
                    // Create new user
                    users[username] = {
                        trophies: 0,
                        createdAt: new Date().toISOString()
                    };
                    
                    // Save to localStorage
                    localStorage.setItem('users', JSON.stringify(users));
                    
                    messageEl.innerHTML = '<div class="success-message">Account created successfully!</div>';
                    
                    // Clear form
                    document.getElementById('newUsername').value = '';
                    
                    // Return to appropriate section after a short delay
                    setTimeout(() => {
                        if (this.currentUser) {
                            this.showMainMenu();
                        } else {
                            this.showAuthSection();
                        }
                        messageEl.innerHTML = '';
                    }, 1500);
                });

                // Sign in form
                document.getElementById('signInSubmitBtn').addEventListener('click', () => {
                    const username = document.getElementById('username').value.trim();
                    const messageEl = document.getElementById('signInMessage');
                    
                    if (!username) {
                        messageEl.innerHTML = '<div class="error-message">Please enter a username</div>';
                        return;
                    }
                    
                    // Get existing users from localStorage
                    let users = JSON.parse(localStorage.getItem('users') || '{}');
                    
                    if (!users[username]) {
                        messageEl.innerHTML = '<div class="error-message">This user was not registered</div>';
                        
                        // Return to appropriate section after a short delay
                        setTimeout(() => {
                            if (this.currentUser) {
                                this.showMainMenu();
                            } else {
                                this.showAuthSection();
                            }
                            messageEl.innerHTML = '';
                            document.getElementById('username').value = '';
                        }, 2000);
                        return;
                    }
                    
                    // Sign in successful
                    this.currentUser = username;
                    localStorage.setItem('currentUser', username);
                    this.loadUserData();
                    
                    // Clear form
                    document.getElementById('username').value = '';
                    
                    // Show main menu
                    this.showMainMenu();
                });

                // Menu tabs
                document.querySelectorAll('.menu-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.menu-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        const tabName = tab.dataset.tab;
                        document.getElementById('playSection').style.display = tabName === 'play' ? 'flex' : 'none';
                        document.getElementById('cardsSection').style.display = tabName === 'cards' ? 'block' : 'none';
                    });
                });

                // Quick match button
                document.querySelector('.play-button').addEventListener('click', () => {
                    // Use default deck with Mega Knight
                    this.playerDeck = ['knight', 'archer', 'demon', 'dragon', 'wizard', 'barbarian', 'minion', 'megaknight', 'tornado', 'fireball', 'freeze'];
                    this.startGame();
                });

                // Card selection
                document.getElementById('cardsGrid').addEventListener('click', (e) => {
                    const cardElement = e.target.closest('.selectable-card');
                    if (!cardElement) return;
                    
                    const cardKey = cardElement.dataset.card;
                    
                    if (this.selectedCards.includes(cardKey)) {
                        // Remove card
                        const index = this.selectedCards.indexOf(cardKey);
                        this.selectedCards.splice(index, 1);
                        cardElement.classList.remove('selected');
                    } else if (this.selectedCards.length < 8) {
                        // Add card
                        this.selectedCards.push(cardKey);
                        cardElement.classList.add('selected');
                    }
                    
                    this.updateSelectedCardsDisplay();
                });

                // Start game button
                document.getElementById('startGameBtn').addEventListener('click', () => {
                    if (this.selectedCards.length === 8) {
                        this.playerDeck = [...this.selectedCards];
                        this.startGame();
                    }
                });

                // Restart button
                document.getElementById('restartBtn').addEventListener('click', () => {
                    location.reload();
                });
            }

            loadUserData() {
                if (!this.currentUser) return;
                
                let users = JSON.parse(localStorage.getItem('users') || '{}');
                if (users[this.currentUser]) {
                    this.trophies = users[this.currentUser].trophies || 0;
                }
            }

            saveUserData() {
                if (!this.currentUser) return;
                
                let users = JSON.parse(localStorage.getItem('users') || '{}');
                if (!users[this.currentUser]) {
                    users[this.currentUser] = { trophies: 0 };
                }
                
                users[this.currentUser].trophies = this.trophies;
                localStorage.setItem('users', JSON.stringify(users));
            }

            updateSelectedCardsDisplay() {
                const slots = document.querySelectorAll('.selected-card-slot');
                slots.forEach((slot, index) => {
                    if (this.selectedCards[index]) {
                        const card = this.allCards[this.selectedCards[index]];
                        if (card.src) {
                            slot.innerHTML = `<img src="${card.src}" width="30px"/>`;
                        } else {
                            slot.textContent = card.icon;
                        }
                    } else {
                        slot.textContent = '';
                    }
                });
                
                const startBtn = document.getElementById('startGameBtn');
                if (this.selectedCards.length === 8) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Game';
                } else {
                    startBtn.disabled = true;
                    startBtn.textContent = `Select ${8 - this.selectedCards.length} More Card${8 - this.selectedCards.length > 1 ? 's' : ''}`;
                }
            }

            updateTrophyDisplay() {
                document.getElementById('trophyCount').textContent = this.trophies;
            }

            startGame() {
                // Hide menu, show game
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('elixirBar').style.display = 'block';
                document.getElementById('timer').style.display = 'block';
                document.getElementById('arena').style.display = 'block';
                document.getElementById('cardDeck').style.display = 'flex';
                
                // Initialize card cycle
                this.cardCycleIndex = 0;
                this.availableCards = this.playerDeck.slice(0, 4); // First 4 cards are available
                this.usedCards = this.playerDeck.slice(4); // Last 4 cards are in the used pile
                
                // Generate enemy deck (random 8 cards)
                const cardKeys = Object.keys(this.allCards);
                this.enemyDeck = [];
                while (this.enemyDeck.length < 8) {
                    const randomCard = cardKeys[Math.floor(Math.random() * cardKeys.length)];
                    if (!this.enemyDeck.includes(randomCard)) {
                        this.enemyDeck.push(randomCard);
                    }
                }
                
                // Create player card deck
                this.createPlayerDeck();
                
                // Create grid
                this.createGrid();
                
                // Setup drag and drop
                this.setupDragAndDrop();
                
                // Start game loops
                this.startElixirGeneration();
                this.startGameLoop();
                this.startAI();
                this.startTimer();
                
                this.gameStarted = true;
            }

            createPlayerDeck() {
                const cardDeck = document.getElementById('cardDeck');
                cardDeck.innerHTML = '';
                
                this.availableCards.forEach((cardKey, index) => {
                    const card = this.allCards[cardKey];
                    const cardElement = document.createElement('div');
                    cardElement.className = 'card';
                    cardElement.draggable = true;
                    cardElement.dataset.card = cardKey;
                    cardElement.dataset.index = index;
                    // Prefer an image when the card defines `src` (e.g. giant)
                    const cardIconHtml = card.src ? `<div class="card-icon"><img src="${card.src}" width="30px"/></div>` : `<div class="card-icon">${card.icon}</div>`;
                    cardElement.innerHTML = `
                        <div class="card-cycle-indicator">${index + 1}</div>
                        ${cardIconHtml}
                        <div class="card-cost">${card.cost}</div>
                    `;
                    cardDeck.appendChild(cardElement);
                });
                
                // Setup drag and drop for the new cards
                this.setupCardDragAndDrop();
            }

            cycleCard(usedCardIndex) {
                // Move the used card to the back of the cycle
                const usedCard = this.availableCards[usedCardIndex];
                
                // Remove from available cards
                this.availableCards.splice(usedCardIndex, 1);
                
                // Add to used cards
                this.usedCards.push(usedCard);
                
                // Take the first card from used cards and add to available
                const nextCard = this.usedCards.shift();
                this.availableCards.push(nextCard);
                
                // Recreate the card deck display
                this.createPlayerDeck();
            }

            createGrid() {
                const arena = document.getElementById('arena');
                
                // Create grid cells
                for (let row = 0; row < this.gridSize.rows; row++) {
                    for (let col = 0; col < this.gridSize.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.style.width = `${this.cellSize.width}px`;
                        cell.style.height = `${this.cellSize.height}px`;
                        cell.style.left = `${col * this.cellSize.width}px`;
                        cell.style.top = `${row * this.cellSize.height}px`;
                        arena.appendChild(cell);
                    }
                }
            }

            setupDragAndDrop() {
                // Setup grid cell drag events (these don't change)
                document.querySelectorAll('.grid-cell').forEach(cell => {
                    cell.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (this.draggedCard) {
                            const row = parseInt(cell.dataset.row, 10);
                            const canDrop = this.canDropDraggedCardOnRow(row);
                            cell.classList.toggle('valid-drop', canDrop);
                            cell.classList.toggle('invalid-drop', !canDrop);
                            if (e.dataTransfer) {
                                e.dataTransfer.dropEffect = canDrop ? 'copy' : 'none';
                            }
                        }
                    });

                    cell.addEventListener('dragleave', () => {
                        cell.classList.remove('valid-drop', 'invalid-drop');
                    });

                    cell.addEventListener('drop', (e) => {
                        e.preventDefault();
                        if (this.draggedCard) {
                            const row = parseInt(cell.dataset.row, 10);
                            const col = parseInt(cell.dataset.col, 10);
                            const placed = this.attemptCardPlacement(row, col);
                            if (placed) {
                                this.endCardDrag();
                            }
                            cell.classList.remove('valid-drop', 'invalid-drop');
                        }
                    });
                });
            }

            setupCardDragAndDrop() {
                // Card drag events
                document.querySelectorAll('.card').forEach(card => {
                    card.addEventListener('dragstart', (e) => {
                        const cardKey = card.dataset.card;
                        const cardIndex = parseInt(card.dataset.index, 10);
                        const canDrag = this.beginCardDrag(card, cardKey, cardIndex);
                        if (!canDrag) {
                            e.preventDefault();
                            return;
                        }
                        if (e.dataTransfer) {
                            e.dataTransfer.effectAllowed = 'copy';
                        }
                    });

                    card.addEventListener('dragend', () => {
                        this.endCardDrag();
                    });

                    card.addEventListener('touchstart', (event) => {
                        this.handleCardTouchStart(event, card);
                    }, { passive: false });
                });
            }

            beginCardDrag(cardElement, cardKey, cardIndex) {
                if (this.draggedCard || this.gameOver) return false;
                const cardData = this.allCards[cardKey];
                if (!cardData) return false;
                if (this.elixir < cardData.cost) return false;

                this.draggedCard = {
                    key: cardKey,
                    index: cardIndex,
                    ...cardData
                };
                this.dragSourceCard = cardElement;
                cardElement.classList.add('dragging');
                return true;
            }

            endCardDrag() {
                if (this.dragSourceCard) {
                    this.dragSourceCard.classList.remove('dragging');
                    this.dragSourceCard = null;
                }
                this.removeTouchPreview();
                this.clearCellHighlights();
                this.draggedCard = null;
                this.touchDragState = null;
                this.detachTouchListeners();
            }

            handleCardTouchStart(event, cardElement) {
                if (this.gameOver) return;
                if (event.touches.length > 1) return;
                if (this.draggedCard) return;

                const cardKey = cardElement.dataset.card;
                const cardIndex = parseInt(cardElement.dataset.index, 10);
                const started = this.beginCardDrag(cardElement, cardKey, cardIndex);
                if (!started) {
                    return;
                }

                const touch = event.changedTouches[0];
                if (!touch) {
                    this.endCardDrag();
                    return;
                }

                event.preventDefault();

                const preview = this.createTouchPreview(cardElement);
                this.touchDragState = {
                    pointerId: touch.identifier,
                    previewElement: preview,
                    activeCell: null,
                    canDrop: false
                };
                this.updateTouchPreviewPosition(touch);
                this.attachTouchListeners();
            }

            attachTouchListeners() {
                if (this.boundTouchMove || this.boundTouchEnd) return;
                this.boundTouchMove = (e) => this.onTouchMove(e);
                this.boundTouchEnd = (e) => this.onTouchEnd(e);
                document.addEventListener('touchmove', this.boundTouchMove, { passive: false });
                document.addEventListener('touchend', this.boundTouchEnd);
                document.addEventListener('touchcancel', this.boundTouchEnd);
            }

            detachTouchListeners() {
                if (this.boundTouchMove) {
                    document.removeEventListener('touchmove', this.boundTouchMove);
                    this.boundTouchMove = null;
                }
                if (this.boundTouchEnd) {
                    document.removeEventListener('touchend', this.boundTouchEnd);
                    document.removeEventListener('touchcancel', this.boundTouchEnd);
                    this.boundTouchEnd = null;
                }
            }

            onTouchMove(event) {
                if (!this.touchDragState) return;
                const touch = this.getTouchById(event.touches, this.touchDragState.pointerId);
                if (!touch) return;

                event.preventDefault();
                this.updateTouchPreviewPosition(touch);
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                const cell = element ? element.closest('.grid-cell') : null;
                this.updateTouchHover(cell);
            }

            onTouchEnd(event) {
                if (!this.touchDragState) return;
                const touch = this.getTouchById(event.changedTouches, this.touchDragState.pointerId);
                if (!touch) return;

                event.preventDefault();

                if (this.touchDragState.activeCell && this.touchDragState.canDrop) {
                    const cell = this.touchDragState.activeCell;
                    const row = parseInt(cell.dataset.row, 10);
                    const col = parseInt(cell.dataset.col, 10);
                    this.attemptCardPlacement(row, col);
                }

                this.endCardDrag();
            }

            createTouchPreview(cardElement) {
                const preview = document.createElement('div');
                preview.className = 'card drag-preview';
                preview.innerHTML = cardElement.innerHTML;
                const scale = this.getContainerScale();
                preview.style.transform = `scale(${scale})`;
                document.body.appendChild(preview);
                return preview;
            }

            updateTouchPreviewPosition(touch) {
                if (!this.touchDragState || !this.touchDragState.previewElement) return;
                const preview = this.touchDragState.previewElement;
                const scale = this.getContainerScale();
                preview.style.transform = `scale(${scale})`;
                const baseWidth = preview.offsetWidth || 70;
                const baseHeight = preview.offsetHeight || 100;
                const halfWidth = (baseWidth * scale) / 2;
                const halfHeight = (baseHeight * scale) / 2;
                preview.style.left = `${touch.clientX - halfWidth}px`;
                preview.style.top = `${touch.clientY - halfHeight}px`;
            }

            removeTouchPreview() {
                if (this.touchDragState && this.touchDragState.previewElement) {
                    this.touchDragState.previewElement.remove();
                    this.touchDragState.previewElement = null;
                }
            }

            clearCellHighlights() {
                document.querySelectorAll('.grid-cell.valid-drop, .grid-cell.invalid-drop').forEach(cell => {
                    cell.classList.remove('valid-drop', 'invalid-drop');
                });
                if (this.touchDragState) {
                    this.touchDragState.activeCell = null;
                    this.touchDragState.canDrop = false;
                }
            }

            updateTouchHover(cell) {
                if (!this.touchDragState) return;
                const previousCell = this.touchDragState.activeCell;
                if (previousCell && previousCell !== cell) {
                    previousCell.classList.remove('valid-drop', 'invalid-drop');
                }

                if (cell && this.draggedCard) {
                    const row = parseInt(cell.dataset.row, 10);
                    const canDrop = this.canDropDraggedCardOnRow(row);
                    cell.classList.toggle('valid-drop', canDrop);
                    cell.classList.toggle('invalid-drop', !canDrop);
                    this.touchDragState.activeCell = cell;
                    this.touchDragState.canDrop = canDrop;
                } else {
                    this.touchDragState.activeCell = null;
                    this.touchDragState.canDrop = false;
                }
            }

            getTouchById(touchList, id) {
                for (let i = 0; i < touchList.length; i++) {
                    if (touchList[i].identifier === id) {
                        return touchList[i];
                    }
                }
                return null;
            }

            getContainerScale() {
                const container = document.getElementById('gameContainer');
                if (!container || !container.offsetWidth) return 1;
                const rect = container.getBoundingClientRect();
                const scale = rect.width / container.offsetWidth;
                return scale || 1;
            }

            canDropDraggedCardOnRow(row) {
                if (!this.draggedCard) return false;
                if (Number.isNaN(row)) return false;
                if (this.draggedCard.type === 'spell' || this.draggedCard.type === 'tower') {
                    return true;
                }
                return row >= 4;
            }

            attemptCardPlacement(row, col) {
                if (!this.draggedCard) return false;
                if (!this.canDropDraggedCardOnRow(row)) return false;
                if (Number.isNaN(col)) return false;
                if (this.elixir < this.draggedCard.cost) return false;

                const x = col * this.cellSize.width + this.cellSize.width / 2;
                const y = row * this.cellSize.height + this.cellSize.height / 2;

                if (this.draggedCard.type === 'spell') {
                    this.castSpell(x, y, this.draggedCard);
                } else {
                    this.spawnUnit(x, y, 'player', this.draggedCard.key);
                }

                this.elixir -= this.draggedCard.cost;
                this.updateElixirDisplay();
                this.cycleCard(this.draggedCard.index);
                return true;
            }

            spawnUnit(x, y, owner, type) {
                const stats = this.allCards[type];
                const unit = {
                    id: Date.now() + Math.random(),
                    x: x,
                    y: y,
                    owner: owner,
                    type: type,
                    health: stats.health,
                    maxHealth: stats.health,
                    damage: stats.damage,
                    speed: stats.speed,
                    range: stats.range,
                    // If the card provides a `src`, store an <img> string for rendering the unit icon (used by Giant)
                    icon: stats.src ? `<img src="${stats.src}" width="20px"/>` : stats.icon,
                    target: null,
                    lastAttack: 0,
                    frozen: false,
                    pathfindingTarget: null,
                    splashDamage: stats.splashDamage || false,
                    splashRadius: stats.splashRadius || 0,
                    jumpDamage: stats.jumpDamage || 0,
                    lastJump: 0,
                    jumping: false,
                    canJumpRiver: stats.canJumpRiver || false,
                    flying: stats.flying || false,
                    canHitAir: stats.canHitAir || false,
                    isTower: stats.type === 'tower',  // Add this property to identify tower units
                    frozenUntil: 0
                };

                // Track base speed and slow state for debuffs
                unit.baseSpeed = stats.speed;
                unit.slowUntil = 0; // timestamp (ms) until which unit is slowed
                unit.slowMultiplier = 1;

                // Prince-specific fields
                if (type === 'prince') {
                    unit.chargeProgress = 0; // ticks spent moving
                    unit.charged = false;    // whether next attack is charged
                }
                
                this.units.push(unit);
                this.createUnitElement(unit);
                // Add flying class to element if applicable
                if (unit.flying) {
                    const el = document.getElementById(`unit-${unit.id}`);
                    if (el) el.classList.add('flying');
                }
                
                // Mega Knight spawn effect - deals splash damage on deployment
                if (type === 'megaknight') {
                    this.createMegaKnightSpawnEffect(x, y, unit);
                }
            }

            createMegaKnightSpawnEffect(x, y, unit) {
                // Create visual effect
                const effect = document.createElement('div');
                effect.className = 'spell-effect megaknight-spawn-effect';
                effect.style.left = `${x - 60}px`;
                effect.style.top = `${y - 60}px`;
                effect.style.width = '120px';
                effect.style.height = '120px';
                effect.style.background = 'radial-gradient(circle, #8B4513, #D2691E, transparent)';
                effect.style.animation = 'spellPulse 0.5s ease-out forwards';
                document.getElementById('arena').appendChild(effect);
                setTimeout(() => effect.remove(), 500);
                
                // Deal flat 250 damage to nearby enemy troops (not towers)
                const spawnRadius = 80; // pixels
                this.units.forEach(enemy => {
                    if (enemy.owner !== unit.owner && !enemy.isTower) {
                        const distance = Math.hypot(enemy.x - x, enemy.y - y);
                        if (distance <= spawnRadius) {
                            // Skip flying enemies if the spawned unit cannot hit air
                            if (!unit.flying && enemy.flying && !unit.canHitAir) return;

                            const damage = 250;
                            enemy.health -= damage;
                            this.updateUnitHealth(enemy);
                            this.showDamageText(enemy.x, enemy.y, damage);

                            if (enemy.health <= 0) {
                                this.removeUnit(enemy);
                            }
                        }
                    }
                });
                
                // Add screen shake effect
                const arena = document.getElementById('arena');
                arena.style.animation = 'screenShake 0.3s';
                setTimeout(() => {
                    arena.style.animation = '';
                }, 300);
            }

            createUnitElement(unit) {
                const element = document.createElement('div');
                element.className = `unit ${unit.owner}`;
                if (unit.isTower) {
                    element.classList.add('tower');
                }
                element.id = `unit-${unit.id}`;
                // Wrap icon in unit-icon; add charge-ring element for Prince
                const iconHtml = `<div class="unit-icon">${unit.icon}${unit.type === 'prince' ? '<div class="charge-ring"></div>' : ''}</div>`;
                element.innerHTML = `
                    <span class="unit-hp-text">${unit.health}</span>
                    ${iconHtml}
                    <div class="health-bar">
                        <div class="health-fill" style="width: 100%"></div>
                    </div>
                `;
                element.style.left = `${unit.x - (unit.isTower ? 25 : 17.5)}px`;
                element.style.top = `${unit.y - (unit.isTower ? 25 : 17.5)}px`;
                document.getElementById('arena').appendChild(element);
            }

            castSpell(x, y, spell) {
                // Create spell effect
                const effect = document.createElement('div');
                effect.className = `spell-effect ${spell.key}-effect`;
                effect.style.left = `${x - spell.radius/2}px`;
                effect.style.top = `${y - spell.radius/2}px`;
                document.getElementById('arena').appendChild(effect);
                setTimeout(() => effect.remove(), 1500);

                // Apply spell effects
                if (spell.key === 'tornado') {
                    // Tornado pulls enemy troops from surrounding 20 tiles
                    this.pullUnitsToTornado(x, y, spell.radius);
                } else if (spell.key === 'fireball' || spell.key === 'lightning' || spell.key === 'arrows') {
                    // Damage spell
                    this.units.forEach(unit => {
                        if (unit.owner === 'enemy') {
                            const distance = Math.sqrt(Math.pow(unit.x - x, 2) + Math.pow(unit.y - y, 2));
                            if (distance <= spell.radius) {
                                unit.health -= spell.damage;
                                this.updateUnitHealth(unit);
                                this.showDamageText(unit.x, unit.y, spell.damage);
                                
                                if (unit.health <= 0) {
                                    this.removeUnit(unit);
                                }
                            }
                        }
                    });

                    // Damage towers
                    ['left', 'right', 'king'].forEach(tower => {
                        const towerElement = document.querySelector(`.tower.enemy[data-tower="${tower}"]`);
                        if (towerElement && !this.towers.enemy[tower].destroyed) {
                            const rect = towerElement.getBoundingClientRect();
                            const arenaRect = document.getElementById('arena').getBoundingClientRect();
                            const towerX = rect.left - arenaRect.left + rect.width / 2;
                            const towerY = rect.top - arenaRect.top + rect.height / 2;
                            
                            const distance = Math.sqrt(Math.pow(towerX - x, 2) + Math.pow(towerY - y, 2));
                            if (distance <= spell.radius) {
                                this.towers.enemy[tower].health -= spell.damage;
                                this.updateTowerHealth('enemy', tower);
                                this.showDamageText(towerX, towerY, spell.damage);
                            }
                        }
                    });
                } else if (spell.key === 'freeze') {
                    // Freeze spell ‚Äî apply an enforced slow to enemy units within radius
                    this.units.forEach(unit => {
                        if (unit.owner === 'enemy') {
                            const distance = Math.sqrt(Math.pow(unit.x - x, 2) + Math.pow(unit.y - y, 2));
                            if (distance <= spell.radius) {
                                        const now = Date.now();
                                        // Freeze: prevent movement and attacking for 4 seconds
                                        const freezeMs = 4000;
                                        unit.frozenUntil = now + freezeMs;
                                        // Add visual frozen class
                                        const el = document.getElementById(`unit-${unit.id}`);
                                        if (el) el.classList.add('frozen');
                                    }
                        }
                    });
                }
            }

            pullUnitsToTornado(tornadoX, tornadoY, radius) {
                this.units.forEach(unit => {
                    if (unit.owner === 'enemy') {
                        const distance = Math.sqrt(Math.pow(unit.x - tornadoX, 2) + Math.pow(unit.y - tornadoY, 2));
                        
                        // Check if unit is in the surrounding area (not the center tile)
                        if (distance > 35 && distance <= radius) {
                            // Calculate pull direction and strength
                            const dx = tornadoX - unit.x;
                            const dy = tornadoY - unit.y;
                            const pullStrength = 0.8; // Strong pull
                            
                            // Apply pull force
                            unit.x += dx * pullStrength;
                            unit.y += dy * pullStrength;
                            
                            // Add visual effect
                            const element = document.getElementById(`unit-${unit.id}`);
                            if (element) {
                                element.classList.add('being-pulled');
                                element.style.left = `${unit.x - 17.5}px`;
                                element.style.top = `${unit.y - 17.5}px`;
                                
                                setTimeout(() => {
                                    element.classList.remove('being-pulled');
                                }, 500);
                            }
                        }
                    }
                });
            }

            updateUnitHealth(unit) {
                const element = document.getElementById(`unit-${unit.id}`);
                if (element) {
                    const healthBar = element.querySelector('.health-fill');
                    const healthText = element.querySelector('.unit-hp-text');
                    const healthPercentage = Math.max(0, (unit.health / unit.maxHealth) * 100);
                    healthBar.style.width = `${healthPercentage}%`;
                    healthText.textContent = Math.max(0, unit.health);
                }
            }

            removeUnit(unit) {
                const element = document.getElementById(`unit-${unit.id}`);
                if (element) {
                    this.createExplosion(unit.x, unit.y);
                    element.remove();
                }
                this.units = this.units.filter(u => u.id !== unit.id);
            }

            startElixirGeneration() {
                setInterval(() => {
                    if (this.elixir < this.maxElixir && !this.gameOver) {
                        this.elixir = Math.min(this.elixir + 0.5, this.maxElixir);
                        this.updateElixirDisplay();
                    }
                }, 1000);
            }

            updateElixirDisplay() {
                const fill = document.getElementById('elixirFill');
                const percentage = (this.elixir / this.maxElixir) * 100;
                fill.style.width = `${percentage}%`;
                fill.textContent = `${Math.floor(this.elixir)}/${this.maxElixir}`;
                
                // Update card availability
                document.querySelectorAll('.card').forEach(card => {
                    const cardKey = card.dataset.card;
                    const cost = this.allCards[cardKey].cost;
                    if (this.elixir < cost) {
                        card.classList.add('disabled');
                    } else {
                        card.classList.remove('disabled');
                    }
                });
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    if (!this.gameOver) {
                        this.timeLeft--;
                        this.updateTimerDisplay();
                        
                        if (this.timeLeft <= 0) {
                            this.endGameByTime();
                        }
                    }
                }, 1000);
            }

            updateTimerDisplay() {
                const minutes = Math.floor(this.timeLeft / 60);
                const seconds = this.timeLeft % 60;
                document.getElementById('timer').textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            }

            endGameByTime() {
                this.gameOver = true;
                
                // Count destroyed towers for each player
                const playerDestroyedTowers = Object.values(this.towers.enemy).filter(t => t.destroyed).length;
                const enemyDestroyedTowers = Object.values(this.towers.player).filter(t => t.destroyed).length;
                
                const gameOverDiv = document.getElementById('gameOver');
                const gameOverText = document.getElementById('gameOverText');
                const trophyChange = document.getElementById('trophyChange');
                
                if (playerDestroyedTowers > enemyDestroyedTowers) {
                    // Player wins
                    gameOverText.textContent = 'Victory! üéâ';
                    gameOverText.style.color = '#4CAF50';
                    trophyChange.textContent = '+30 Trophies';
                    this.trophies += 30;
                } else if (enemyDestroyedTowers > playerDestroyedTowers) {
                    // Enemy wins
                    gameOverText.textContent = 'Defeat! üíî';
                    gameOverText.style.color = '#f44336';
                    trophyChange.textContent = '-30 Trophies';
                    this.trophies -= 30;
                } else {
                    // Tie
                    gameOverText.textContent = 'Tie! ü§ù';
                    gameOverText.style.color = '#FFC107';
                    trophyChange.textContent = '+10 Trophies';
                    this.trophies += 10;
                }
                
                // Save user data with updated trophies
                this.saveUserData();
                
                gameOverDiv.style.display = 'flex';
            }

            startGameLoop() {
                setInterval(() => {
                    if (!this.gameOver) {
                        this.updateUnits();
                        this.checkGameOver();
                    }
                }, 50);
            }

            updateUnits() {
                this.units.forEach(unit => {
                    // Skip update while unit is jumping or preparing to jump
                    if (unit.jumping || unit.preparing) return;
                    
                    const element = document.getElementById(`unit-${unit.id}`);
                    if (!element) return;

                    // Expire slow if needed
                    if (unit.slowUntil && Date.now() > unit.slowUntil) {
                        unit.slowUntil = 0;
                        unit.slowMultiplier = 1;
                        if (element) element.classList.remove('frozen');
                    }

                    // Expire freeze if needed
                    if (unit.frozenUntil && Date.now() > unit.frozenUntil) {
                        unit.frozenUntil = 0;
                        if (element) element.classList.remove('frozen');
                    }

                    // Special handling for Mega Knight jump ability
                    if (unit.type === 'megaknight') {
                        const now = Date.now();
                        const jumpCooldown = unit.jumpCooldown || 3000;
                        
                        // Check if it's time to jump and there's an enemy in range
                        if (now - unit.lastJump > jumpCooldown) {
                            const nearestEnemy = this.findNearestEnemy(unit, unit.jumpRange || 120);

                            // Determine a valid jump target: don't jump at flying units
                            let jumpTarget = null;
                            if (nearestEnemy) {
                                if (nearestEnemy.flying) {
                                    // Find nearest non-flying enemy unit within range
                                    let minD = unit.jumpRange || 120;
                                    this.units.forEach(o => {
                                        if (o.owner !== unit.owner && !o.flying) {
                                            const d = Math.hypot(o.x - unit.x, o.y - unit.y);
                                            if (d < minD) {
                                                minD = d;
                                                jumpTarget = o;
                                            }
                                        }
                                    });

                                    // If no non-flying unit found, allow jumping at towers (they are ground)
                                    if (!jumpTarget) {
                                        const enemyTowers = unit.owner === 'player' ? 
                                            document.querySelectorAll('.tower.enemy:not(.destroyed)') : 
                                            document.querySelectorAll('.tower.player:not(.destroyed)');
                                        let minTD = unit.jumpRange || 120;
                                        enemyTowers.forEach(tower => {
                                            const rect = tower.getBoundingClientRect();
                                            const arenaRect = document.getElementById('arena').getBoundingClientRect();
                                            const towerX = rect.left - arenaRect.left + rect.width / 2;
                                            const towerY = rect.top - arenaRect.top + rect.height / 2;
                                            const d = Math.hypot(towerX - unit.x, towerY - unit.y);
                                            if (d < minTD) {
                                                minTD = d;
                                                jumpTarget = { x: towerX, y: towerY, type: 'tower', owner: unit.owner === 'player' ? 'enemy' : 'player', tower: tower.dataset.tower };
                                            }
                                        });
                                    }
                                } else {
                                    jumpTarget = nearestEnemy;
                                }
                            }

                            if (jumpTarget) {
                                // If currently attacking this enemy and it's within attack range, don't jump at it
                                let skipJump = false;
                                if (unit.target) {
                                    // Tower target comparison
                                    if (unit.target.type === 'tower' && jumpTarget.type === 'tower') {
                                        if (unit.target.owner === jumpTarget.owner && unit.target.tower === jumpTarget.tower) {
                                            const dx = (unit.target.x || jumpTarget.x) - unit.x;
                                            const dy = (unit.target.y || jumpTarget.y) - unit.y;
                                            if (Math.sqrt(dx*dx + dy*dy) <= unit.range) skipJump = true;
                                        }
                                    } else if (unit.target.id && jumpTarget.id && unit.target.id === jumpTarget.id) {
                                        const dx = jumpTarget.x - unit.x;
                                        const dy = jumpTarget.y - unit.y;
                                        if (Math.sqrt(dx*dx + dy*dy) <= unit.range) skipJump = true;
                                    }
                                }

                                if (!skipJump) {
                                    this.performMegaKnightJump(unit, jumpTarget);
                                    unit.lastJump = now;
                                    return;
                                }
                            }
                        }
                    }

                    // Find target - validate existing target first
                    if (unit.target) {
                        // Check if current target is still valid
                        if (!this.isValidTarget(unit, unit.target)) {
                            unit.target = null; // Clear invalid target
                        }
                    }

                    // For troops: always pick the closest target each tick (troop or tower)
                    // This allows a troop that was going for a tower to switch to a nearer enemy when it appears.
                    const stats = this.allCards[unit.type] || {};
                    if (stats.type === 'troop') {
                        unit.target = this.findTarget(unit);
                    } else {
                        // Find new target if needed for non-troops
                        if (!unit.target) {
                            unit.target = this.findTarget(unit);
                        }
                    }

                    // Move towards target or attack (skip movement/attacks while frozen)
                    if (unit.target) {
                        if (unit.frozenUntil && Date.now() < unit.frozenUntil) {
                            // Unit is frozen: skip movement and attacking this tick
                            return;
                        }
                        const targetElement = this.getTargetElement(unit.target);
                        if (targetElement) {
                            const dx = unit.target.x - unit.x;
                            const dy = unit.target.y - unit.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance > unit.range) {
                                // Calculate movement with river avoidance
                                if (!unit.isTower) { // Tower units don't move
                                    const movement = this.calculateMovement(unit, unit.target);
                                    if (movement) {
                                        unit.x = movement.x;
                                        unit.y = movement.y;
                                        element.style.left = `${unit.x - (unit.isTower ? 25 : 17.5)}px`;
                                        element.style.top = `${unit.y - (unit.isTower ? 25 : 17.5)}px`;

                                        // Prince charging: increment progress while moving and not already charged
                                        if (unit.type === 'prince' && !unit.charged) {
                                            unit.chargeProgress = (unit.chargeProgress || 0) + 1;
                                            const stats = this.allCards[unit.type];
                                            if (unit.chargeProgress >= (stats.chargeThreshold || 60)) {
                                                unit.charged = true;
                                                // Visual indicator
                                                element.classList.add('charging');
                                            }
                                        }
                                    }
                                }
                            } else {
                                // Attack
                                const now = Date.now();
                                const attackInterval = (this.allCards[unit.type] && this.allCards[unit.type].attackInterval) || 1000;
                                if (now - unit.lastAttack > attackInterval) {
                                    this.attack(unit, unit.target);
                                    unit.lastAttack = now;
                                    
                                    // Check if target was destroyed after attack
                                    if (unit.target.type === 'tower') {
                                        if (this.towers[unit.target.owner][unit.target.tower].destroyed) {
                                            unit.target = null; // Clear target immediately
                                        }
                                    } else {
                                        // Check if unit was destroyed
                                        if (!this.units.includes(unit.target)) {
                                            unit.target = null; // Clear target immediately
                                        }
                                    }
                                }
                            }
                        } else {
                            // Target element not found, clear target
                            unit.target = null;
                        }
                    } else {
                        // Move towards enemy towers (only for non-tower units)
                        if (!unit.isTower) {
                            const direction = unit.owner === 'player' ? -1 : 1;
                            const movement = this.calculateMovement(unit, { 
                                x: unit.x, 
                                y: unit.y + (direction * 100) 
                            });
                            if (movement) {
                                unit.x = movement.x;
                                unit.y = movement.y;
                                element.style.left = `${unit.x - (unit.isTower ? 25 : 17.5)}px`;
                                element.style.top = `${unit.y - (unit.isTower ? 25 : 17.5)}px`;
                            }
                        }
                    }
                });
            }

            findNearestEnemy(unit, maxDistance) {
                let nearestEnemy = null;
                let minDistance = maxDistance;

                // Check enemy units
                this.units.forEach(other => {
                    if (other.owner !== unit.owner) {
                        const distance = Math.sqrt(
                            Math.pow(other.x - unit.x, 2) + 
                            Math.pow(other.y - unit.y, 2)
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestEnemy = other;
                        }
                    }
                });

                // Check enemy towers if no units found
                if (!nearestEnemy) {
                    const enemyTowers = unit.owner === 'player' ? 
                        document.querySelectorAll('.tower.enemy:not(.destroyed)') : 
                        document.querySelectorAll('.tower.player:not(.destroyed)');
                    
                    enemyTowers.forEach(tower => {
                        const rect = tower.getBoundingClientRect();
                        const arenaRect = document.getElementById('arena').getBoundingClientRect();
                        const towerX = rect.left - arenaRect.left + rect.width / 2;
                        const towerY = rect.top - arenaRect.top + rect.height / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(towerX - unit.x, 2) + 
                            Math.pow(towerY - unit.y, 2)
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestEnemy = {
                                x: towerX,
                                y: towerY,
                                type: 'tower',
                                owner: unit.owner === 'player' ? 'enemy' : 'player',
                                tower: tower.dataset.tower
                            };
                        }
                    });
                }

                return nearestEnemy;
            }

            performMegaKnightJump(unit, target) {
                // If already preparing or jumping, do nothing
                if (unit.preparing || unit.jumping) return;

                // Enter preparing state (stop moving) and show pre-jump effect
                unit.preparing = true;
                const element = document.getElementById(`unit-${unit.id}`);
                if (element) element.classList.add('preparing');
                this.createPreJumpEffect(unit.x, unit.y);

                // After a short delay perform the actual jump (allows a wind-up effect)
                setTimeout(() => {
                    // If target is no longer valid, cancel preparation
                    if (!this.isValidTarget(unit, target)) {
                        unit.preparing = false;
                        if (element) element.classList.remove('preparing');
                        return;
                    }

                    unit.preparing = false;
                    if (element) element.classList.remove('preparing');

                    // Now perform the jump with animation (slower travel)
                    unit.jumping = true;
                    if (element) element.classList.add('jumping');

                    // Recalculate destination in case target moved
                    const dx = target.x - unit.x;
                    const dy = target.y - unit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                    const dirX = dx / distance;
                    const dirY = dy / distance;
                    const jumpDistance = Math.min(distance, unit.jumpRange || 80);
                    const newX = unit.x + dirX * jumpDistance;
                    const newY = unit.y + dirY * jumpDistance;

                    // Create takeoff effect
                    this.createJumpEffect(unit.x, unit.y);

                    // Animate movement over duration (slower jump)
                    const startX = unit.x;
                    const startY = unit.y;
                    const jumpDuration = unit.jumpDuration || 800; // ms
                    const startTime = performance.now();

                    const animate = (now) => {
                        const elapsed = now - startTime;
                        const t = Math.min(1, elapsed / jumpDuration);
                        // easeOutQuad for a snappy end
                        const ease = 1 - Math.pow(1 - t, 2);
                        unit.x = startX + (newX - startX) * ease;
                        unit.y = startY + (newY - startY) * ease;
                        if (element) {
                            element.style.left = `${unit.x - 17.5}px`;
                            element.style.top = `${unit.y - 17.5}px`;
                        }

                        if (t < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Landing
                            this.createJumpEffect(unit.x, unit.y);
                            this.dealJumpDamage(unit);
                            unit.target = null;
                            setTimeout(() => {
                                if (element) element.classList.remove('jumping');
                                unit.jumping = false;
                            }, 300);
                        }
                    };

                    requestAnimationFrame(animate);
                }, 500); // 500ms pre-jump delay
            }

            createJumpEffect(x, y) {
                const effect = document.createElement('div');
                effect.className = 'spell-effect jump-effect';
                effect.style.left = `${x - 40}px`;
                effect.style.top = `${y - 40}px`;
                effect.style.width = '80px';
                effect.style.height = '80px';
                effect.style.background = 'radial-gradient(circle, #8B4513, #D2691E, transparent)';
                effect.style.animation = 'spellPulse 0.3s ease-out forwards';
                document.getElementById('arena').appendChild(effect);
                setTimeout(() => effect.remove(), 300);
            }

            createPreJumpEffect(x, y) {
                const effect = document.createElement('div');
                effect.className = 'spell-effect prejump-effect';
                effect.style.left = `${x - 30}px`;
                effect.style.top = `${y - 30}px`;
                effect.style.width = '60px';
                effect.style.height = '60px';
                effect.style.background = 'radial-gradient(circle, rgba(255,215,0,0.9), rgba(255,165,0,0.6), transparent)';
                effect.style.borderRadius = '50%';
                effect.style.animation = 'spellPulse 0.5s ease-out forwards';
                document.getElementById('arena').appendChild(effect);
                setTimeout(() => effect.remove(), 500);
            }

            dealJumpDamage(unit) {
                // Deal damage to nearby enemies
                this.units.forEach(enemy => {
                    if (enemy.owner !== unit.owner) {
                        const distance = Math.sqrt(
                            Math.pow(enemy.x - unit.x, 2) + 
                            Math.pow(enemy.y - unit.y, 2)
                        );
                        
                        if (distance <= 80) { // Jump damage radius
                            // Skip flying units if the jumper is ground and cannot hit air
                            if (!unit.flying && enemy.flying && !unit.canHitAir) return;

                            enemy.health -= unit.jumpDamage;
                            this.updateUnitHealth(enemy);
                            this.showDamageText(enemy.x, enemy.y, unit.jumpDamage);
                            
                            if (enemy.health <= 0) {
                                this.removeUnit(enemy);
                            }
                        }
                    }
                });
                
                // Check for tower damage
                const enemyTowers = unit.owner === 'player' ? 
                    ['left', 'right', 'king'].map(tower => ({
                        type: 'tower',
                        owner: 'enemy',
                        tower: tower,
                        element: document.querySelector(`.tower.enemy[data-tower="${tower}"]:not(.destroyed)`)
                    })) : 
                    ['left', 'right', 'king'].map(tower => ({
                        type: 'tower',
                        owner: 'player',
                        tower: tower,
                        element: document.querySelector(`.tower.player[data-tower="${tower}"]:not(.destroyed)`)
                    }));
                
                enemyTowers.forEach(tower => {
                    if (tower.element) {
                        const rect = tower.element.getBoundingClientRect();
                        const arenaRect = document.getElementById('arena').getBoundingClientRect();
                        const towerX = rect.left - arenaRect.left + rect.width / 2;
                        const towerY = rect.top - arenaRect.top + rect.height / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(towerX - unit.x, 2) + 
                            Math.pow(towerY - unit.y, 2)
                        );
                        
                        if (distance <= 80) { // Jump damage radius
                            this.towers[tower.owner][tower.tower].health -= unit.jumpDamage;
                            this.updateTowerHealth(tower.owner, tower.tower);
                            this.showDamageText(towerX, towerY, unit.jumpDamage);
                            
                            if (this.towers[tower.owner][tower.tower].health <= 0) {
                                this.towers[tower.owner][tower.tower].destroyed = true;
                                this.destroyTower(tower.owner, tower.tower);
                            }
                        }
                    }
                });
            }

            calculateMovement(unit, target) {
                const dx = target.x - unit.x;
                const dy = target.y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance === 0) return null;
                
                // Normalize direction
                const dirX = dx / distance;
                const dirY = dy / distance;
                
                // Calculate movement speed taking slows into account
                const base = unit.baseSpeed || unit.speed || 1;
                const multiplier = (unit.slowMultiplier !== undefined) ? unit.slowMultiplier : 1;
                let speed = base * multiplier;

                // Slight Prince charging speed bonus: +0.5% while charging (i.e., has progress but not yet charged)
                if (unit.type === 'prince' && unit.chargeProgress > 0 && !unit.charged) {
                    speed = speed * 1.005; // 0.5% faster
                }

                // Calculate new position using effective speed
                let newX = unit.x + dirX * speed;
                let newY = unit.y + dirY * speed;
                
                // Check if unit would cross the river (flying units ignore river)
                const crossingRiver = !unit.flying && (
                    (unit.y < this.riverTop && newY >= this.riverTop) || 
                    (unit.y > this.riverBottom && newY <= this.riverBottom)
                );
                
                // Special case for Hog Rider - can jump over river
                if (unit.type === 'hogrider' && crossingRiver) {
                    // Create jump effect
                    this.createJumpEffect(unit.x, unit.y);
                    
                    // Jump directly to the other side of the river
                    if (unit.y < this.riverTop) {
                        // Jumping from top to bottom
                        newY = this.riverBottom + 20;
                    } else {
                        // Jumping from bottom to top
                        newY = this.riverTop - 20;
                    }
                    
                    // Create landing effect
                    this.createJumpEffect(newX, newY);
                    
                    // Keep within bounds
                    newX = Math.max(17.5, Math.min(402.5, newX));
                    newY = Math.max(17.5, Math.min(532.5, newY));
                    
                    return { x: newX, y: newY };
                }
                
                if (crossingRiver) {
                    // Find nearest bridge
                    const nearestBridge = this.findNearestBridge(unit.x);
                    if (nearestBridge) {
                        // Check if unit is on the bridge
                        const onBridge = unit.x >= nearestBridge.left && unit.x <= nearestBridge.right;
                        
                        if (!onBridge) {
                            // Move towards bridge
                            const bridgeDx = nearestBridge.centerX - unit.x;
                            const bridgeDy = 0;
                            const bridgeDistance = Math.abs(bridgeDx);
                            
                            if (bridgeDistance > 5) {
                                // Move horizontally towards bridge
                                newX = unit.x + (bridgeDx / bridgeDistance) * speed;
                                newY = unit.y; // Don't move vertically while approaching bridge
                            } else {
                                // On bridge, can cross river
                                newY = unit.y + dirY * speed;
                            }
                        } else {
                            // On bridge, can cross river
                            newY = unit.y + dirY * speed;
                        }
                    } else {
                        // No bridge found, don't cross river
                        newY = unit.y;
                    }
                }
                
                // Keep within bounds
                newX = Math.max(17.5, Math.min(402.5, newX));
                newY = Math.max(17.5, Math.min(532.5, newY));
                
                return { x: newX, y: newY };
            }

            findNearestBridge(x) {
                let nearestBridge = null;
                let minDistance = Infinity;
                
                this.bridges.forEach(bridge => {
                    const distance = Math.abs(x - bridge.centerX);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestBridge = bridge;
                    }
                });
                
                return nearestBridge;
            }

            findTarget(unit) {
                // Get unit stats to check for special targeting
                const stats = this.allCards[unit.type];
                // Use a global troop engagement radius for consistency
                const maxTargetDist = this.troopTargetRange || 200;
                
                // Special case: Units that only target towers
                if (stats && stats.targetsTowersOnly) {
                    // Check for decoy towers first (they have higher priority)
                    const decoyTowers = this.units.filter(u => 
                        u.owner !== unit.owner && 
                        u.isTower && 
                        u.type === 'decoy'
                    );
                    
                    if (decoyTowers.length > 0) {
                        // Find nearest decoy tower
                        let nearestDecoy = null;
                        let minDistance = Infinity;
                        
                        decoyTowers.forEach(decoy => {
                            const distance = Math.sqrt(
                                Math.pow(decoy.x - unit.x, 2) + 
                                Math.pow(decoy.y - unit.y, 2)
                            );
                            // Ignore decoys outside engagement radius
                            if (distance > maxTargetDist) return;
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestDecoy = decoy;
                            }
                        });
                        
                        return nearestDecoy;
                    }
                    
                    // If no decoy towers, target main towers
                    const enemyTowers = unit.owner === 'player' ? 
                        document.querySelectorAll('.tower.enemy:not(.destroyed)') : 
                        document.querySelectorAll('.tower.player:not(.destroyed)');
                    
                    let nearestTower = null;
                    let minDistance = Infinity;
                    
                    enemyTowers.forEach(tower => {
                        const rect = tower.getBoundingClientRect();
                        const arenaRect = document.getElementById('arena').getBoundingClientRect();
                        const towerX = rect.left - arenaRect.left + rect.width / 2;
                        const towerY = rect.top - arenaRect.top + rect.height / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(towerX - unit.x, 2) + 
                            Math.pow(towerY - unit.y, 2)
                        );
                        // Only consider towers within engagement radius
                        if (distance > maxTargetDist) return;
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestTower = {
                                x: towerX,
                                y: towerY,
                                type: 'tower',
                                owner: unit.owner === 'player' ? 'enemy' : 'player',
                                tower: tower.dataset.tower
                            };
                        }
                    });
                    
                    return nearestTower;
                }

                // Normal target finding for other units
                // Troop behavior: pick the closest between nearest enemy unit and nearest tower
                // (Prince used to have this behavior ‚Äî apply it to all troops)
                if (stats && stats.type === 'troop') {
                    // Find nearest enemy unit
                    let nearestUnit = null;
                    let unitDist = Infinity;
                    this.units.forEach(other => {
                        if (other.owner !== unit.owner) {
                            // If this unit is ground and the other is flying, skip it unless this unit can hit air
                            if (!unit.flying && other.flying && !unit.canHitAir) return;
                            const distance = Math.sqrt(
                                Math.pow(other.x - unit.x, 2) + 
                                Math.pow(other.y - unit.y, 2)
                            );
                            // Ignore units beyond engagement radius
                            if (distance > maxTargetDist) return;
                            if (distance < unitDist) {
                                unitDist = distance;
                                nearestUnit = other;
                            }
                        }
                    });

                    // Find nearest tower (we still evaluate towers regardless of maxTargetDist so troops will move toward them if no nearby enemies)
                    let nearestTower = null;
                    let towerDist = Infinity;
                    const enemyTowers = unit.owner === 'player' ? 
                        document.querySelectorAll('.tower.enemy:not(.destroyed)') : 
                        document.querySelectorAll('.tower.player:not(.destroyed)');
                    enemyTowers.forEach(tower => {
                        const rect = tower.getBoundingClientRect();
                        const arenaRect = document.getElementById('arena').getBoundingClientRect();
                        const towerX = rect.left - arenaRect.left + rect.width / 2;
                        const towerY = rect.top - arenaRect.top + rect.height / 2;
                        const distance = Math.sqrt(
                            Math.pow(towerX - unit.x, 2) + 
                            Math.pow(towerY - unit.y, 2)
                        );
                        if (distance < towerDist) {
                            towerDist = distance;
                            nearestTower = {
                                x: towerX,
                                y: towerY,
                                type: 'tower',
                                owner: unit.owner === 'player' ? 'enemy' : 'player',
                                tower: tower.dataset.tower
                            };
                        }
                    });

                    // Compare distances and return the closer target (unit preferred on tie).
                    // If no nearby unit is within maxTargetDist, still return the nearest tower so troops will push toward towers.
                    if (nearestUnit && (!nearestTower || unitDist <= towerDist)) {
                        return nearestUnit;
                    }
                    return nearestTower;
                }

                // Default behavior for other (non-troop) units: nearest enemy unit, then nearest tower
                let nearestTarget = null;
                let minDistance = Infinity;

                // Check enemy units
                this.units.forEach(other => {
                    if (other.owner !== unit.owner) {
                        // Ground units shouldn't consider flying enemies as targets unless they can hit air
                        if (!unit.flying && other.flying && !unit.canHitAir) return;
                        const distance = Math.sqrt(
                            Math.pow(other.x - unit.x, 2) + 
                            Math.pow(other.y - unit.y, 2)
                        );
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestTarget = other;
                        }
                    }
                });

                // Check enemy towers if no units found
                if (!nearestTarget) {
                    const enemyTowers = unit.owner === 'player' ? 
                        document.querySelectorAll('.tower.enemy:not(.destroyed)') : 
                        document.querySelectorAll('.tower.player:not(.destroyed)');
                    
                    enemyTowers.forEach(tower => {
                        const rect = tower.getBoundingClientRect();
                        const arenaRect = document.getElementById('arena').getBoundingClientRect();
                        const towerX = rect.left - arenaRect.left + rect.width / 2;
                        const towerY = rect.top - arenaRect.top + rect.height / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(towerX - unit.x, 2) + 
                            Math.pow(towerY - unit.y, 2)
                        );
                        // Ignore towers outside engagement radius
                        if (distance > maxTargetDist) return;
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestTarget = {
                                x: towerX,
                                y: towerY,
                                type: 'tower',
                                owner: unit.owner === 'player' ? 'enemy' : 'player',
                                tower: tower.dataset.tower
                            };
                        }
                    });
                }

                return nearestTarget;
            }

            isValidTarget(unit, target) {
                if (target.type === 'tower') {
                    return this.towers[target.owner][target.tower].health > 0 && 
                           !this.towers[target.owner][target.tower].destroyed;
                }
                return this.units.includes(target);
            }

            getTargetElement(target) {
                if (target.type === 'tower') {
                    return document.querySelector(`.tower.${target.owner}[data-tower="${target.tower}"]:not(.destroyed)`);
                }
                return document.getElementById(`unit-${target.id}`);
            }

            attack(attacker, target) {
                // Prince charged attack: apply bonus then reset
                let appliedDamage = attacker.damage;
                if (attacker.type === 'prince' && attacker.charged) {
                    const stats = this.allCards[attacker.type];
                    appliedDamage = Math.floor(attacker.damage * (stats.chargeBonusMultiplier || 2));
                    attacker.charged = false;
                    attacker.chargeProgress = 0;
                    const attackerEl = document.getElementById(`unit-${attacker.id}`);
                    if (attackerEl) attackerEl.classList.remove('charging');
                }

                if (this.allCards[attacker.type] && this.allCards[attacker.type].projectile && target) {
                    // spawn projectile visual and resolve hit when it arrives
                    this.fireProjectile(attacker, target, this.allCards[attacker.type]);
                    return;
                }

                if (target.type === 'tower') {
                    this.towers[target.owner][target.tower].health -= appliedDamage;
                    this.updateTowerHealth(target.owner, target.tower);
                    this.showDamageText(target.x, target.y, appliedDamage);
                    
                    if (this.towers[target.owner][target.tower].health <= 0) {
                        this.towers[target.owner][target.tower].destroyed = true;
                        this.destroyTower(target.owner, target.tower);
                    }
                } else {
                    // If attacker is ground and target is flying, ground attacks do not affect flying units
                    // unless the attacker canHitAir
                    if (!attacker.flying && target.flying && !attacker.canHitAir) {
                        return; // ignore hit
                    }

                    target.health -= appliedDamage;
                    this.updateUnitHealth(target);
                    this.showDamageText(target.x, target.y, appliedDamage);

                    // Don't allow ground attackers to hit flying targets unless they canHitAir
                    if (!attacker.flying && target.flying && !attacker.canHitAir) {
                        return; // ignore hit
                    }

                    // Apply slow on every hit to enemy units (use attacker's slow params if present)
                    if (target && target.id && target.owner !== attacker.owner) {
                        const atkStats = this.allCards[attacker.type] || {};
                        const now = Date.now();
                        const newMultiplier = (atkStats.slowMultiplier !== undefined) ? atkStats.slowMultiplier : 0.8;
                        const duration = atkStats.slowDuration || 1000;

                        // Prefer the stronger slow (smaller multiplier) if already slowed
                        const currentMult = target.slowMultiplier || 1;
                        target.slowMultiplier = Math.min(currentMult, newMultiplier);
                        target.slowUntil = now + duration;
                        const el = document.getElementById(`unit-${target.id}`);
                        if (el) el.classList.add('frozen');

                        // Brief blue hit flash only if attacker's card opts in
                        if (atkStats.showHitFlash && el) {
                            el.classList.add('hit-blue');
                            setTimeout(() => el.classList.remove('hit-blue'), 200);
                        }

                        // If attacker has an AoE slow radius (like icewizard), also apply to nearby enemies
                        if (atkStats.slowRadius) {
                            this.units.forEach(u => {
                                if (u.owner !== attacker.owner && u !== target) {
                                    const dist = Math.sqrt(Math.pow(u.x - target.x, 2) + Math.pow(u.y - target.y, 2));
                                    if (dist <= atkStats.slowRadius) {
                                        const cur = u.slowMultiplier || 1;
                                        u.slowMultiplier = Math.min(cur, newMultiplier);
                                        u.slowUntil = now + duration;
                                        const eu = document.getElementById(`unit-${u.id}`);
                                        if (eu) eu.classList.add('frozen');
                                        if (atkStats.showHitFlash && eu) {
                                            eu.classList.add('hit-blue');
                                            setTimeout(() => eu.classList.remove('hit-blue'), 200);
                                        }
                                    }
                                }
                            });
                        }

                    }

                    if (target.health <= 0) {
                        this.removeUnit(target);
                    }
                }
                
                // Handle splash damage for units that have it
                if (attacker.splashDamage && target.type !== 'tower') {
                    this.dealSplashDamage(attacker, target);
                }
            }

            fireProjectile(attacker, target, stats) {
                const arena = document.getElementById('arena');
                const startEl = document.getElementById(`unit-${attacker.id}`) || this.getTargetElement(attacker);
                const targetEl = this.getTargetElement(target);
                if (!startEl || !targetEl) return;

                const rectStart = startEl.getBoundingClientRect();
                const rectArena = arena.getBoundingClientRect();
                const sx = rectStart.left - rectArena.left + rectStart.width / 2;
                const sy = rectStart.top - rectArena.top + rectStart.height / 2;

                const rectTarget = targetEl.getBoundingClientRect();
                const tx = rectTarget.left - rectArena.left + rectTarget.width / 2;
                const ty = rectTarget.top - rectArena.top + rectTarget.height / 2;

                const proj = document.createElement('div');
                proj.className = `projectile ${stats.projectileClass || ''}`.trim();
                proj.style.left = `${sx}px`;
                proj.style.top = `${sy}px`;
                arena.appendChild(proj);

                const speed = stats.projectileSpeed || 0.5; // fraction of distance per 50ms tick
                const dx = tx - sx;
                const dy = ty - sy;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const step = Math.max(2, distance * speed * 0.05);
                let traveled = 0;

                const data = { attackerId: attacker.id, targetId: target.id, dmg: attacker.damage, stats };

                const iv = setInterval(() => {
                    traveled += step;
                    const t = Math.min(1, traveled / distance);
                    const cx = sx + dx * t;
                    const cy = sy + dy * t;
                    proj.style.left = `${cx}px`;
                    proj.style.top = `${cy}px`;

                    // check collision (if within 10px)
                    if (Math.abs(cx - tx) < 10 && Math.abs(cy - ty) < 10) {
                        clearInterval(iv);
                        this.applyProjectileHit(proj, data, target);
                    }
                }, 30);
                // safety cleanup
                setTimeout(() => { clearInterval(iv); if (proj.parentNode) proj.remove(); }, 5000);
            }

            applyProjectileHit(projEl, data, target) {
                if (projEl && projEl.parentNode) projEl.remove();

                // re-resolve target validity and apply damage
                const attacker = this.units.find(u => u.id === data.attackerId) || this.units.find(u => u.id === data.attackerId);
                if (!target) return;
                if (target.type === 'tower') {
                    this.towers[target.owner][target.tower].health -= data.dmg;
                    this.updateTowerHealth(target.owner, target.tower);
                    this.showDamageText(target.x, target.y, data.dmg);
                    if (this.towers[target.owner][target.tower].health <= 0) {
                        this.towers[target.owner][target.tower].destroyed = true;
                        this.destroyTower(target.owner, target.tower);
                    }
                    return;
                }

                // If attacker is ground and target is flying, ground projectiles may still hit if attacker.canHitAir
                if (attacker && !attacker.flying && target.flying && !attacker.canHitAir) return;

                target.health -= data.dmg;
                this.updateUnitHealth(target);
                this.showDamageText(target.x, target.y, data.dmg);

                // handle splash if projectile belongs to a splash unit (like wiz)
                if (data.stats && data.stats.splashDamage) {
                    this.dealSplashDamage(data.stats, target);
                }

                if (target.health <= 0) this.removeUnit(target);
            }

            dealSplashDamage(attacker, primaryTarget) {
                this.units.forEach(unit => {
                    if (unit !== primaryTarget && unit.owner !== attacker.owner) {
                        const distance = Math.sqrt(
                            Math.pow(unit.x - primaryTarget.x, 2) + 
                            Math.pow(unit.y - primaryTarget.y, 2)
                        );
                        
                        if (distance <= attacker.splashRadius) {
                            // Skip flying units if attacker is ground and cannot hit air
                            if (!attacker.flying && unit.flying && !attacker.canHitAir) return;

                            const splashDamage = attacker.damage * 0.5; // 50% damage for splash
                            unit.health -= splashDamage;
                            this.updateUnitHealth(unit);
                            this.showDamageText(unit.x, unit.y, splashDamage);
                            
                            // (No special-case slow for specific unit types)

                            if (unit.health <= 0) {
                                this.removeUnit(unit);
                            }
                        }
                    }
                });
            }

            destroyTower(owner, tower) {
                const towerElement = document.querySelector(`.tower.${owner}[data-tower="${tower}"]`);
                if (towerElement) {
                    towerElement.classList.add('destroyed');
                    this.createExplosion(
                        parseInt(towerElement.style.left) + parseInt(towerElement.style.width) / 2,
                        parseInt(towerElement.style.top) + parseInt(towerElement.style.height) / 2
                    );
                }
            }

            updateTowerHealth(owner, tower) {
                const towerElement = document.querySelector(`.tower.${owner}[data-tower="${tower}"]:not(.destroyed)`);
                if (!towerElement) return;
                
                const healthBar = towerElement.querySelector('.tower-health-bar');
                const healthText = towerElement.querySelector('.tower-hp-text');
                const health = Math.max(0, this.towers[owner][tower].health);
                const maxHealth = this.towers[owner][tower].maxHealth;
                const percentage = (health / maxHealth) * 100;
                healthBar.style.width = `${percentage}%`;
                healthText.textContent = health;
            }

            showDamageText(x, y, damage) {
                const text = document.createElement('div');
                text.className = 'damage-text';
                text.textContent = `-${damage}`;
                text.style.left = `${x}px`;
                text.style.top = `${y}px`;
                document.getElementById('arena').appendChild(text);
                setTimeout(() => text.remove(), 1000);
            }

            createExplosion(x, y) {
                const explosion = document.createElement('div');
                explosion.className = 'explosion';
                explosion.style.left = `${x - 20}px`;
                explosion.style.top = `${y - 20}px`;
                document.getElementById('arena').appendChild(explosion);
                setTimeout(() => explosion.remove(), 300);
            }

            checkGameOver() {
                const playerKingHealth = this.towers.player.king.health;
                const enemyKingHealth = this.towers.enemy.king.health;

                if (playerKingHealth <= 0 || enemyKingHealth <= 0) {
                    this.gameOver = true;
                    clearInterval(this.timerInterval);
                    
                    const gameOverDiv = document.getElementById('gameOver');
                    const gameOverText = document.getElementById('gameOverText');
                    const trophyChange = document.getElementById('trophyChange');
                    
                    if (enemyKingHealth <= 0) {
                        gameOverText.textContent = 'Victory! üéâ';
                        gameOverText.style.color = '#4CAF50';
                        trophyChange.textContent = '+30 Trophies';
                        this.trophies += 30;
                    } else {
                        gameOverText.textContent = 'Defeat! üíî';
                        gameOverText.style.color = '#f44336';
                        trophyChange.textContent = '-30 Trophies';
                        this.trophies -= 30;
                    }
                    
                    // Save user data with updated trophies
                    this.saveUserData();
                    
                    gameOverDiv.style.display = 'flex';
                }
                
                // Check if all towers of one side are destroyed
                const playerTowersDestroyed = Object.values(this.towers.player).filter(t => t.destroyed).length;
                const enemyTowersDestroyed = Object.values(this.towers.enemy).filter(t => t.destroyed).length;
                
                if (playerTowersDestroyed === 3 || enemyTowersDestroyed === 3) {
                    this.gameOver = true;
                    clearInterval(this.timerInterval);
                    
                    const gameOverDiv = document.getElementById('gameOver');
                    const gameOverText = document.getElementById('gameOverText');
                    const trophyChange = document.getElementById('trophyChange');
                    
                    if (enemyTowersDestroyed === 3) {
                        gameOverText.textContent = 'Victory! üéâ';
                        gameOverText.style.color = '#4CAF50';
                        trophyChange.textContent = '+30 Trophies';
                        this.trophies += 30;
                    } else {
                        gameOverText.textContent = 'Defeat! üíî';
                        gameOverText.style.color = '#f44336';
                        trophyChange.textContent = '-30 Trophies';
                        this.trophies -= 30;
                    }
                    
                    // Save user data with updated trophies
                    this.saveUserData();
                    
                    gameOverDiv.style.display = 'flex';
                }
            }

            startAI() {
                setInterval(() => {
                    if (!this.gameOver && this.elixir >= 2) {
                        // AI spawns units in top half
                        const randomCard = this.enemyDeck[Math.floor(Math.random() * this.enemyDeck.length)];
                        const cardData = this.allCards[randomCard];
                        
                        // Random position in top half (rows 0-3)
                        const col = Math.floor(Math.random() * this.gridSize.cols);
                        const row = Math.floor(Math.random() * 4);
                        
                        const x = col * this.cellSize.width + this.cellSize.width / 2;
                        const y = row * this.cellSize.height + this.cellSize.height / 2;
                        
                        if (cardData.type === 'spell') {
                            // Cast spell at random player location
                            const targetCol = Math.floor(Math.random() * this.gridSize.cols);
                            const targetRow = 4 + Math.floor(Math.random() * 4);
                            const targetX = targetCol * this.cellSize.width + this.cellSize.width / 2;
                            const targetY = targetRow * this.cellSize.height + this.cellSize.height / 2;
                            this.castSpell(targetX, targetY, { ...cardData, key: randomCard });
                        } else {
                            this.spawnUnit(x, y, 'enemy', randomCard);
                        }
                    }
                }, 4000);
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>